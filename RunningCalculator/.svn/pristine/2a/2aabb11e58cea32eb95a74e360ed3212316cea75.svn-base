package pmg.android.runningcalculator.data;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import pmg.android.runningcalculator.data.InputValue.InputValueType;

public class InputValueGenerator {
	private static Pattern canBeInt = Pattern.compile("^[0-9]+$");
	private static Pattern canBeDouble = Pattern.compile("^[0-9]+\\.{1}[0-9]+$");
	private static Pattern canBeTwoPartTime = Pattern.compile("^([0-9]{1,2})[\\.:,]{1}([0-5]{0,1}[0-9]{1})$");
	private static Pattern canBeHoursMinsSeconds = Pattern.compile("^([0-9]{1,2})([\\.:,]{1})([0-5]{0,1}[0-9]{1})\\2([0-5]{0,1}[0-9]{1})$");

	public static InputValueList generateValuesFromSeed(String seed) {
		List<InputValue> list = new ArrayList<InputValue>();

		if (canBeInt.matcher(seed).find()) {
			addIntCandidates(Integer.parseInt(seed), list);
		} else if (canBeDouble.matcher(seed).find()) {
			addDoubleCandidates(Double.parseDouble(seed), list);
		}
		Matcher matcher = canBeTwoPartTime.matcher(seed);
		if (matcher.find()) {
			// time in hours and minutes
			list.add(new InputValue(InputValueType.TIME_SECONDS, Integer.parseInt(matcher.group(1)) * 60 * 60 + Integer.parseInt(matcher.group(2))
					* 60));
			// time in minutes and seconds
			double timeSeconds = Integer.parseInt(matcher.group(1)) * 60 + Integer.parseInt(matcher.group(2));
			list.add(new InputValue(InputValueType.TIME_SECONDS, timeSeconds));

			tryAddPaces(list, timeSeconds);
		}
		matcher = canBeHoursMinsSeconds.matcher(seed);
		if (matcher.find()) {
			list.add(new InputValue(InputValueType.TIME_SECONDS, Integer.parseInt(matcher.group(1)) * 60 * 60 + Integer.parseInt(matcher.group(3))
					* 60 + Integer.parseInt(matcher.group(4))));
		}

		return new InputValueList(seed,list);
	}

	private static void addIntCandidates(int value, List<InputValue> list) {
		addDoubleCandidates((double) value, list);
	}

	private static void addDoubleCandidates(double value, List<InputValue> list) {
		if (value >= 1 && value <= 125)
			list.add(new InputValue(InputValueType.DISTANCE_TRACKLAPS, value));
		if (value >= 1 && value <= 100)
			list.add(new InputValue(InputValueType.DISTANCE_KILOMETRES, value));
		if (value >= 1 && value <= 100)
			list.add(new InputValue(InputValueType.DISTANCE_MILES, value));
		if (value >= 100 && value <= 10000)
			list.add(new InputValue(InputValueType.DISTANCE_METRES, value));
		if (value >= 0) {
			if(value < 24 * 60 * 60)
				list.add(new InputValue(InputValueType.TIME_SECONDS, value));
			if(value < 24 * 60 )
				list.add(new InputValue(InputValueType.TIME_SECONDS, value * 60));
			if(value < 24 )
				list.add(new InputValue(InputValueType.TIME_SECONDS, value * 60 * 60));
		}

		tryAddPaces(list, value);
		tryAddPaces(list, value * 60);

		if (value >= RunningConstants.SPEED_WALKING_KPH && value <= RunningConstants.SPEED_SPRINT_KPH)
			list.add(new InputValue(InputValueType.SPEED_KPH, value));
		if (value >= RunningConstants.SPEED_WALKING_MPH && value <= RunningConstants.SPEED_SPRINT_MPH)
			list.add(new InputValue(InputValueType.SPEED_MPH, value));
	}

	private static void tryAddPaces(List<InputValue> list, double timeInSeconds) {
		if (timeInSeconds <= RunningConstants.PACE_WALKING_SEC_PER_KM && timeInSeconds >= RunningConstants.PACE_SPRINT_SEC_PER_KM)
			list.add(new InputValue(InputValueType.PACE_SEC_PER_KM, timeInSeconds));
		if (timeInSeconds <= RunningConstants.PACE_WALKING_SEC_PER_MILE && timeInSeconds >= RunningConstants.PACE_SPRINT_SEC_PER_MILE)
			list.add(new InputValue(InputValueType.PACE_SEC_PER_MILE, timeInSeconds));

	}
}
